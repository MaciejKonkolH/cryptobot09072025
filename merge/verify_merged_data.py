import pandas as pd
import numpy as np
import argparse
import os
import sys
from datetime import datetime

def load_merged_data(input_file="merged_ohlc_orderbook.feather"):
    """Wczytuje po≈ÇƒÖczone dane"""
    print(f"üìä Wczytujƒô po≈ÇƒÖczone dane z {input_file}...")
    
    if not os.path.exists(input_file):
        print(f"‚ùå Plik {input_file} nie istnieje!")
        return None
    
    df = pd.read_feather(input_file)
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    
    print(f"‚úÖ Wczytano {len(df):,} wierszy")
    print(f"‚è∞ Zakres: {df['timestamp'].min()} do {df['timestamp'].max()}")
    print(f"üìã Liczba kolumn: {len(df.columns)}")
    
    return df

def analyze_missing_data(df):
    """Analizuje brakujƒÖce dane w szczeg√≥≈Çach"""
    print(f"\nüîç SZCZEG√ì≈ÅOWA ANALIZA BRAKUJƒÑCYCH DANYCH")
    print("=" * 80)
    
    # 1. Og√≥lne statystyki brakujƒÖcych danych
    total_cells = len(df) * len(df.columns)
    missing_cells = df.isnull().sum().sum()
    missing_percentage = (missing_cells / total_cells) * 100
    
    print(f"üìä OG√ìLNE STATYSTYKI:")
    print(f"  ≈ÅƒÖczna liczba kom√≥rek: {total_cells:,}")
    print(f"  BrakujƒÖce kom√≥rki: {missing_cells:,}")
    print(f"  Procent brakujƒÖcych: {missing_percentage:.2f}%")
    
    # 2. Analiza kolumn z brakujƒÖcymi danymi
    missing_by_column = df.isnull().sum()
    columns_with_missing = missing_by_column[missing_by_column > 0].sort_values(ascending=False)
    
    print(f"\nüìã KOLUMNY Z BRAKUJƒÑCYMI DANYMI:")
    if len(columns_with_missing) > 0:
        print(f"  Znaleziono {len(columns_with_missing)} kolumn z brakujƒÖcymi danymi:")
        print()
        
        for i, (col, count) in enumerate(columns_with_missing.items(), 1):
            percentage = (count / len(df)) * 100
            print(f"  {i:2d}. {col}:")
            print(f"      Brakuje: {count:,} wierszy ({percentage:.2f}%)")
            
            # Dodatkowe informacje dla kolumn orderbook
            if col.startswith(('snapshot1_', 'snapshot2_')):
                print(f"      Typ: Orderbook snapshot")
            elif col in ['open', 'high', 'low', 'close', 'volume']:
                print(f"      Typ: OHLC")
            else:
                print(f"      Typ: Inne")
            print()
    else:
        print("  ‚úÖ Brak kolumn z brakujƒÖcymi danymi!")
    
    # 3. Analiza wierszy z brakujƒÖcymi danymi
    missing_by_row = df.isnull().sum(axis=1)
    rows_with_missing = missing_by_row[missing_by_row > 0]
    
    print(f"üìä ANALIZA WIERSZY Z BRAKUJƒÑCYMI DANYMI:")
    if len(rows_with_missing) > 0:
        print(f"  Wiersze z brakujƒÖcymi danymi: {len(rows_with_missing):,} ({len(rows_with_missing)/len(df)*100:.2f}%)")
        
        # Statystyki liczby brakujƒÖcych kolumn na wiersz
        missing_counts = rows_with_missing.value_counts().sort_index()
        print(f"  Rozk≈Çad liczby brakujƒÖcych kolumn na wiersz:")
        for missing_count, row_count in missing_counts.head(10).items():
            print(f"    {missing_count} kolumn brakuje: {row_count:,} wierszy")
        
        if len(missing_counts) > 10:
            print(f"    ... i {len(missing_counts) - 10} wiƒôcej kategorii")
    else:
        print("  ‚úÖ Brak wierszy z brakujƒÖcymi danymi!")
    
    # 4. Analiza czasowa brakujƒÖcych danych
    print(f"\n‚è∞ ANALIZA CZASOWA BRAKUJƒÑCYCH DANYCH:")
    
    # Znajd≈∫ wiersze z brakujƒÖcymi danymi orderbook
    orderbook_columns = [col for col in df.columns if col.startswith(('snapshot1_', 'snapshot2_'))]
    if orderbook_columns:
        first_ob_col = orderbook_columns[0]
        missing_orderbook_rows = df[df[first_ob_col].isna()]
        
        if len(missing_orderbook_rows) > 0:
            print(f"  Wiersze bez danych orderbook: {len(missing_orderbook_rows):,}")
            print(f"  Zakres czasowy brakujƒÖcych orderbook:")
            print(f"    Od: {missing_orderbook_rows['timestamp'].min()}")
            print(f"    Do: {missing_orderbook_rows['timestamp'].max()}")
            
            # Sprawd≈∫ czy sƒÖ luki czasowe
            missing_timestamps = missing_orderbook_rows['timestamp'].sort_values()
            if len(missing_timestamps) > 1:
                time_diffs = missing_timestamps.diff().dropna()
                max_gap = time_diffs.max()
                print(f"  Maksymalna luka czasowa: {max_gap}")
        else:
            print("  ‚úÖ Wszystkie wiersze majƒÖ dane orderbook!")
    
    # 5. Analiza kolumn OHLC
    ohlc_columns = ['open', 'high', 'low', 'close', 'volume']
    print(f"\nüìà ANALIZA KOLUMN OHLC:")
    for col in ohlc_columns:
        if col in df.columns:
            missing_count = df[col].isna().sum()
            if missing_count > 0:
                percentage = (missing_count / len(df)) * 100
                print(f"  {col}: {missing_count:,} brakujƒÖcych ({percentage:.2f}%)")
            else:
                print(f"  {col}: ‚úÖ Brak brakujƒÖcych danych")
        else:
            print(f"  {col}: ‚ùå Kolumna nie istnieje")
    
    return {
        'total_rows': len(df),
        'total_columns': len(df.columns),
        'missing_cells': missing_cells,
        'missing_percentage': missing_percentage,
        'columns_with_missing': len(columns_with_missing),
        'rows_with_missing': len(rows_with_missing)
    }

def check_data_quality(df):
    """Sprawdza jako≈õƒá danych"""
    print(f"\nüî¨ SPRAWDZANIE JAKO≈öCI DANYCH")
    print("=" * 80)
    
    issues = []
    
    # 1. Sprawd≈∫ warto≈õci ujemne w cenach
    price_columns = ['open', 'high', 'low', 'close']
    for col in price_columns:
        if col in df.columns:
            negative_prices = (df[col] < 0).sum()
            if negative_prices > 0:
                issues.append(f"Ujemne ceny w {col}: {negative_prices:,} wierszy")
    
    # 2. Sprawd≈∫ sp√≥jno≈õƒá OHLC
    if all(col in df.columns for col in price_columns):
        invalid_ohlc = (
            (df['high'] < df['low']) |
            (df['open'] > df['high']) |
            (df['close'] > df['high']) |
            (df['open'] < df['low']) |
            (df['close'] < df['low'])
        ).sum()
        
        if invalid_ohlc > 0:
            issues.append(f"Niesp√≥jne dane OHLC: {invalid_ohlc:,} wierszy")
    
    # 3. Sprawd≈∫ warto≈õci zerowe w volume
    if 'volume' in df.columns:
        zero_volume = (df['volume'] == 0).sum()
        if zero_volume > 0:
            issues.append(f"Zerowy volume: {zero_volume:,} wierszy")
    
    # 4. Sprawd≈∫ orderbook snapshoty
    orderbook_columns = [col for col in df.columns if col.startswith(('snapshot1_', 'snapshot2_'))]
    if orderbook_columns:
        # Sprawd≈∫ czy sƒÖ warto≈õci ujemne w orderbook
        for col in orderbook_columns:
            if df[col].dtype in ['float64', 'int64']:
                negative_values = (df[col] < 0).sum()
                if negative_values > 0:
                    issues.append(f"Ujemne warto≈õci w {col}: {negative_values:,} wierszy")
    
    # 5. Sprawd≈∫ duplikaty timestamp√≥w
    duplicate_timestamps = df['timestamp'].duplicated().sum()
    if duplicate_timestamps > 0:
        issues.append(f"Duplikaty timestamp√≥w: {duplicate_timestamps:,} wierszy")
    
    # Wy≈õwietl wyniki
    if issues:
        print("‚ùå ZNALEZIONE PROBLEMY:")
        for i, issue in enumerate(issues, 1):
            print(f"  {i}. {issue}")
    else:
        print("‚úÖ Brak problem√≥w z jako≈õciƒÖ danych!")
    
    return issues

def generate_report(stats, issues, output_file="data_verification_report.txt"):
    """Generuje raport z weryfikacji"""
    print(f"\nüìÑ GENEROWANIE RAPORTU...")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("RAPORT WERYFIKACJI DANYCH PO ≈ÅƒÑCZENIU OHLC Z ORDERBOOK\n")
        f.write("=" * 80 + "\n")
        f.write(f"Data generowania: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        f.write("PODSUMOWANIE STATYSTYK:\n")
        f.write(f"  ≈ÅƒÖczna liczba wierszy: {stats['total_rows']:,}\n")
        f.write(f"  ≈ÅƒÖczna liczba kolumn: {stats['total_columns']:,}\n")
        f.write(f"  BrakujƒÖce kom√≥rki: {stats['missing_cells']:,}\n")
        f.write(f"  Procent brakujƒÖcych: {stats['missing_percentage']:.2f}%\n")
        f.write(f"  Kolumny z brakujƒÖcymi danymi: {stats['columns_with_missing']}\n")
        f.write(f"  Wiersze z brakujƒÖcymi danymi: {stats['rows_with_missing']:,}\n\n")
        
        f.write("PROBLEMY Z JAKO≈öCIƒÑ:\n")
        if issues:
            for i, issue in enumerate(issues, 1):
                f.write(f"  {i}. {issue}\n")
        else:
            f.write("  Brak problem√≥w z jako≈õciƒÖ danych\n")
    
    print(f"‚úÖ Raport zapisany: {output_file}")

def main():
    """G≈Ç√≥wna funkcja"""
    parser = argparse.ArgumentParser(description='Weryfikuje po≈ÇƒÖczone dane OHLC z orderbook')
    parser.add_argument('--input', default='merged_ohlc_orderbook.feather', 
                       help='≈öcie≈ºka do po≈ÇƒÖczonego pliku danych')
    parser.add_argument('--report', default='data_verification_report.txt',
                       help='Nazwa pliku raportu')
    
    args = parser.parse_args()
    
    print("üîç ROZPOCZYNAM WERYFIKACJƒò PO≈ÅƒÑCZONYCH DANYCH")
    print("=" * 80)
    
    # Wczytaj dane
    df = load_merged_data(args.input)
    if df is None:
        return
    
    # Analizuj brakujƒÖce dane
    stats = analyze_missing_data(df)
    
    # Sprawd≈∫ jako≈õƒá danych
    issues = check_data_quality(df)
    
    # Wygeneruj raport
    generate_report(stats, issues, args.report)
    
    print(f"\nüéâ WERYFIKACJA ZAKO≈ÉCZONA!")
    print(f"üìÅ Raport: {args.report}")
    
    # Podsumowanie
    if stats['missing_percentage'] > 10:
        print(f"‚ö†Ô∏è  UWAGA: Wysoki procent brakujƒÖcych danych ({stats['missing_percentage']:.2f}%)")
    elif stats['missing_percentage'] > 5:
        print(f"‚ö†Ô∏è  Uwaga: ≈öredni procent brakujƒÖcych danych ({stats['missing_percentage']:.2f}%)")
    else:
        print(f"‚úÖ Niski procent brakujƒÖcych danych ({stats['missing_percentage']:.2f}%)")
    
    if issues:
        print(f"‚ö†Ô∏è  Znaleziono {len(issues)} problem√≥w z jako≈õciƒÖ danych")
    else:
        print("‚úÖ Brak problem√≥w z jako≈õciƒÖ danych")

if __name__ == "__main__":
    main() 